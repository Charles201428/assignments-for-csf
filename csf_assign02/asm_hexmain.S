//my original attempt to write asm based on c code fails (it just seg fal forever and i can't fix it), so i now use a new approach.


	.section .rodata
sSpace:  		.string " "
sTripleSpace: 	.string "   "
sColon:			.string ": "
sNewLine:		.string "\n"

    .section .data
data: .space 17 //the data read by hex_read
single_hex: .space 3 /* char array to hold a single byte in hex format. 1 additional byte for '\0' */
offset_hex: .space 9 //hex[8] generated by hex_format_offset
printable: .space 17 //printable version of data
offset: .quad 0 //unsigned argument for hex_format_offset
readlength: .quad 0 //returned value of hex_read

	.section .text

/*
* Print offset in 8-digit hexadecimal format.
*
* same parameter as printoffset in c file
*/
print_offset:

    pushq %rbp 
    movq %rsi, %rbp //save rsi
    call hex_format_offset /* set offset_hex to correct string*/
    movq %rbp, %rdi //rdi = offset
    call hex_write_string /* print offset_hex */
    popq %rbp 
    ret


/*
* similar to printloop in c
*
* first three arguements are the same while having the fourth arg as ' '
*/
print_input_chars:
    pushq %r15 
    pushq %r14 
    pushq %r13 
    pushq %r12 
    pushq %rbx /* store callee-saved register */
    movq $0, %r12 //r12 = counter
    movq %rsi, %r13 //r13 = data[17]
    movq %rdi, %r14 //r14 = readlength
    movq %rdx, %r15 //r15 = hex[3]
    movq %rcx, %rbx //rbx = ' '
    jmp .forloopend1
.forloopt1:
    movq $0, %rdi /* clean %rdi for later use of  %dil*/
    movb (%r13, %r12), %dil //dil = data[i]
    movq %r15, %rsi //rsi = hex
    call hex_format_byte_as_hex 
    movq %r15, %rdi //rdi = formated hex
    call hex_write_string 
    movq %rbx, %rdi //rdi = ' '
    call hex_write_string 
    addq $1, %r12 //i++
.forloopend1:
    cmpq %r14, %r12 //if i < readlength
    jl .forloopt1
    popq %rbx 
    popq %r12 
    popq %r13 
    popq %r14 
    popq %r15 
    ret




/* basically printsupplement in c main
 * 
 *
 *
 *
 */
printsupplement:
    /* fill the empty gap*/
    pushq %r12 /* store callee-saved register */
    pushq %r13 
    pushq %r14 
    movq %rdi, %r12 //r12 = readlength
    movq %rsi, %r13 //r13 = ' '
    movq %rdx, %r14 //r14 = '   '
    jmp .Condition
.insideloop:
    movq %r14, %rdi //rdi = '   '
    call hex_write_string 
    addq $1, %r12 //i++
.Condition:
    cmpq $16, %r12 //if i < 16, loop!
    jl .insideloop 
    movq %r13, %rdi //rdi = ' '
    call hex_write_string 
    popq %r14 
    popq %r13 
    popq %r12 
    ret


/*
 * 
 * same function as defined in c main
 *
 * Parameters:
 * with third variable rbx storing the original hex byte
 */

print_printable:
    subq $8, %rsp /* adjust stack pointer*/
    pushq %rbp /* store callee-saved register */
    pushq %r13 
    pushq %r14 
    pushq %r15 
    
    movq $0, %rbp //i = 0
    movq %rsi, %r13 //r13 = created printable
    movq %rdx, %r14 //r14 = data
    movq %rdi, %r15 //r15 = readlength
    jmp .printableloopend
.printableloop:
    movq $0, %rdi /* clean %rdi for later use of %dil */
    movb (%r14, %rbp), %dil // dil = data[i]
    call hex_to_printable //hex_to_printable(data[i])
    movb %al, (%r13, %rbp) //data[i] = hex_to_printable(data[i])
    addq $1, %rbp 
.printableloopend:
    cmpq %r15, %rbp //make sure i < readlength
    jl .printableloop 
    movb $0, (%r13, %rbp) //null terminator
    movq %r13, %rdi // rdi = converted printable string
    call hex_write_string /* print the string */
    popq %r15 
    popq %r14 
    popq %r13 
    popq %rbp
    addq $8, %rsp 
    ret








	.globl main
    main:
    pushq %rbp

.mainwhileloop:
    /* print offset in 8-digit hexadecimal format. */
    movq $data, %rdi //rdi = data
    call hex_read 
    movq %rax, readlength /* record number of bytes read */
    cmpq $0, readlength //if readlength <=0 end the whole thing
    jle .mainend
    
    //offset
    movq offset, %rdi
    movq $offset_hex, %rsi
    call print_offset

    //colon
    movq $sColon, %rdi 
    call hex_write_string 

    //hex representation
    movq readlength, %rdi
    movq $data, %rsi
    movq $single_hex, %rdx
    movq $sSpace, %rcx
    call print_input_chars

    //supplement
    movq readlength, %rdi
    movq $sSpace, %rsi
    movq $sTripleSpace, %rdx
    call printsupplement

    /* print printable string */
    movq readlength, %rdi
    movq $printable, %rsi
    movq $data, %rdx
    call print_printable

    movq $sNewLine, %rdi 
    call hex_write_string 
    movq readlength, %rbp 
    addq %rbp, offset /* update offset */
    jmp .mainwhileloop

.mainend:
    popq %rbp 
    ret